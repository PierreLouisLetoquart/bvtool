use std::fs;
use std::io::Write;

fn read_file(file_path: &str) -> Vec<u8> {
    fs::read(file_path).expect("Unable to read the file")
}

fn create_empty_map(rows: usize, cols: usize) -> Vec<Vec<u32>> {
    vec![vec![0; cols]; rows]
}

fn process_bytes(bytes: &[u8], map: &mut Vec<Vec<u32>>) {
    for window in bytes.windows(2) {
        let curr = window[0] as usize;
        let next = window[1] as usize;
        map[curr][next] += 1;
    }
}

fn find_max_value(map: &[Vec<u32>]) -> u32 {
    map.iter()
        .flat_map(|row| row.iter())
        .copied()
        .fold(0, u32::max)
}

fn scale_map(map: &[Vec<u32>], min: u32, max: u32) -> Vec<Vec<u8>> {
    map.iter()
        .map(|row| {
            row.iter()
                .map(|&x| ((x - min) as u32 * 255 / (max - min)) as u8)
                .collect()
        })
        .collect()
}

fn write_ppm(scaled_map: &Vec<Vec<u8>>, output_path: &str) -> std::io::Result<()> {
    let mut ppm_file = fs::File::create(output_path)?;

    // PPM header
    write!(ppm_file, "P6\n256 256\n# Generated by bvtool.rs\n255\n")?;

    // Write RGB values
    for row in scaled_map {
        for &value in row {
            write!(ppm_file, "{} {} {} ", value, value, value)?;
        }
    }

    ppm_file.sync_all()?;
    Ok(())
}

fn main() {
    let file_path = "./data/img.jpg";
    let bytes = read_file(file_path);
    let mut map = create_empty_map(256, 256);

    process_bytes(&bytes, &mut map);

    let max_value = find_max_value(&map);

    let min = 0;
    let scaled_map = scale_map(&map, min, max_value);

    // TODO: fix the write ppm function
    let output_path = "./data/output.ppm";
    write_ppm(&scaled_map, output_path).unwrap();
}
